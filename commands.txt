BOOTNODE
When a new node joins the Ethereum network it needs to connect to nodes that are already on the network in order to then discover new peers.
 These entry points into the Ethereum network are called bootnodes. Clients usually have a list of bootnodes hardcoded into them.
 These bootnodes are typically run by the Ethereum Foundation's devops team or client teams themselves. 
Note that bootnodes are not the same as static nodes. Static nodes are called over and over again,
 whereas bootnodes are only called upon if there are not enough peers to connect to and a node needs to bootstrap some new connections
 
 Bootnode is a clone of fullnode, not lightnode
 
 Go based ethereum nodes can mine with CPU and GPU. On a private deployment you can mine with CPU.
 
 . In private networks for development or testing purposes, specify at least one bootnode.
 . Bootnodes and static nodes are parallel methods for finding peers.6 dni temu
 
 Bootnodes are the nodes which provide information about other peers, txns, blocks. Once that information is received,
 bootnode does not need to be online. But bootnodes are always kept online,
 because new nodes keep coming up and require some of this information.
 
 
 Yes. Bootnode can be validator nodes. It does not matter whether bootnode is validator or non validator.
 For all other nodes, it is just some node which can be used to get information of other nodes and get previous blockchain data.
 NOTE: Since the validator node needs to expose its enode address (enode://pubkey1@ip1:port1) and thus the validator node's IP address in order to be a Bootnode,
 having validator nodes serve as Bootnodes (and advertising this) makes it easier for network attackers (DDOS) to target validator nodes.
 
 The P2P protocol requires that you indicate at least a bootnode from which your discovery will start. 
 Bootnode is a venue for new nodes otherwise they can't know where to start searching for peers.
 

geth account list | awk '/Account #0:/ {print $3}' | sed 's/{\(.*\)}/0x\1/'


cat ~/.ethereum/geth/nodekey
cd ~/.ethereum/keystore/

echo '41c1f2a156e887b28f94674a7552b1beb9c332f920e1e0b6bc660c648bf1749b'> file.txt
echo '8916c74217220507c0140583e42e9261bebadaf5792d0f0b9f5a9c418922622b'> file.txt
echo '304a37d2c97b27caf3446314477be422d5a4c637b675d5d883cb2fcb11647358'> file.txt
geth account import --password /tmp/password file.txt
geth account import  file.txt

cat ~/.ethereum/keystore/UTC--2023-11-28T23-00-00.359584223Z--e8f3bfc65e31c04ccc8b3e73d6b6e3b4874dfd7f

geth account new --datadir data
Public address of the key:   0x99F7F06D5DCdfFdc0a3a89C055765dBacc76059d
Path of the secret key file: data/keystore/UTC--2023-11-28T21-59-23.032106294Z--99f7f06d5dcdffdc0a3a89c055765dbacc76059d

{"address":"99f7f06d5dcdffdc0a3a89c055765dbacc76059d","crypto":{"cipher":"aes-128-ctr",
"ciphertext":"404e702fbc0aab3830e674ef4edba477fbed20de8696cee992c50d95019b7de3",
"cipherparams":{"iv":"472acc260d7d6147186202f7f72e5004"},"kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,
"salt":"c9fb113be792edfc3922cad063a04213e918b813d5c129710de36d7b47c210f2"},"mac":"df37a606745a8ff1498f9b0d47de18886e6dba40e1a76289189bfd17caff0b7c"},
"id":"5d3ba2bd-b14c-47ba-bcc9-ad9cb02e5cd1","version":3}/ #

The nodekey file is used to generate the Geth enode which is kind of the id of each node in Ethereum network.

nodekeyhex - potrzebujemy hardcoded, bo tworzone jest na podstawie nodekey, a z kolei na nodekey bazuje enode, czyli id

Etherbase, also called coinbase, is the public key of an Ether account,

curl -s -X POST --data '{"jsonrpc":"2.0","method":"net_version","params":[],"id":1}' -H "Content-Type: application/json" "http://localhost:8545"

curl -s -X POST --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' -H "Content-Type: application/json" "http://localhost:8545"
$ curl -s -X POST --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' -H "Content-Type: application/json" "http://geth-bootnode:8545"

geth javascript console
geth attach
# Now, within the geth JavaScript console:
eth.getBalance("C1C171Aa00656c46852A867061bA439C6b4641F6")
eth.getBalance("347381d459f2854b6f217be187b6cf6c5f53104a")
eth.getBalance("caa5191965956a87de379f9666c7033faa90232b")



eth.sendTransaction({from: "caa5191965956a87de379f9666c7033faa90232b", to: "C1C171Aa00656c46852A867061bA439C6b4641F6", value: web3.toWei(1, "ether")})

nc -zv localhost 30304
admin.peers
admin.nodeInfo
eth.getBlock(0).hash
eth.getBlock("latest")
list sealers clique.getSigners()
list propositions: clique.proposals
discard a proposition: clique.discard("0x1234234234234")
add a new sealer: clique.propose("0x8132ac3481ff1c3e871d4ea34b4069edb5ed0f99", true)
remove a sealer: clique.propose("0x8132ac3481ff1c3e871d4ea34b4069edb5ed0f99", false)
web3.personal.unlockAccount('0d1915640f9449305b5ca966892ff4f522833b85', 'test')

admin.addPeer("enode://c038a67f8fcddb4fa7cf544ac4855e7acbf5578e4071ba6d57cd1eb94959fbd172d424dacc107413c59c05ff48756e801af5a5bc47913b8bda830b2b23af59f1@geth-bootnode:30303")
admin.addPeer("enode://c038a67f8fcddb4fa7cf544ac4855e7acbf5578e4071ba6d57cd1eb94959fbd172d424dacc107413c59c05ff48756e801af5a5bc47913b8bda830b2b23af59f1@geth-node-1:30304")
admin.addPeer("enode://eec3a5bbc9230397880a24c968c52f1eb09baecd63701f1d039e8a5749c7752c9e505aad6d33397a13094a4705c9efbe283bb4e12665f13f9b4aa0ee0b65ab52@geth-node-2:30305")




To encode the signer addresses in extradata, concatenate 32 zero bytes, all signer addresses and 65 further zero bytes.
 The result of this concatenation is then used as the value accompanying the extradata key in genesis.json.
 In the example below, extradata contains a single initial signer address, 0x7df9a875a174b3bc565e6424a0050ebc1b2d1d82.